---
description: the guide to develop ui components for SoybeanHeadless
globs:
alwaysApply: false
---
# SoybeanHeadless - Complete Development Guide

You are an expert Vue 3 + TypeScript developer working on the **SoybeanHeadless** component library. This comprehensive guide will help you understand the project structure, coding standards, and development patterns to build consistent, accessible, and high-quality headless UI components.

## ğŸ—ï¸ Project Overview

**SoybeanHeadless** is a collection of primitive headless UI components for Vue 3, designed to be lightweight, accessible, and highly customizable.

### Core Features
- **Headless Design**: Zero built-in styling, maximum customization freedom
- **Type Safety**: Complete TypeScript support with strict mode
- **Accessibility**: Full ARIA support and keyboard navigation
- **Composable**: Built with Vue 3 Composition API
- **Context-aware**: Uses provide/inject for component communication

### Technology Stack
- **Framework**: Vue 3 with Composition API (`<script setup>`)
- **Language**: TypeScript (strict mode)
- **Build Tools**: Vite + tsdown
- **Styling**: UnoCSS + CSS Variables
- **Testing**: Vitest
- **Package Manager**: pnpm
- **Architecture**: Headless UI Components (no built-in styling)

## ğŸ“ Repository Structure

```
soybean-headless/
â”œâ”€â”€ ğŸ“¦ src/                           # Source code
â”‚   â”œâ”€â”€ ğŸ§© components/                # Component library
â”‚   â”‚   â”œâ”€â”€ accordion/                # Accordion component suite
â”‚   â”‚   â”œâ”€â”€ alert-dialog/             # Alert dialog component
â”‚   â”‚   â”œâ”€â”€ arrow/                    # Arrow component
â”‚   â”‚   â”œâ”€â”€ aspect-ratio/             # Aspect ratio component
â”‚   â”‚   â”œâ”€â”€ avatar/                   # Avatar component suite
â”‚   â”‚   â”œâ”€â”€ collapsible/              # Collapsible component
â”‚   â”‚   â”œâ”€â”€ config-provider/          # Configuration provider
â”‚   â”‚   â”œâ”€â”€ dialog/                   # Dialog component
â”‚   â”‚   â”œâ”€â”€ portal/                   # Portal/Teleport component
â”‚   â”‚   â”œâ”€â”€ primitive/                # Base primitive component
â”‚   â”‚   â””â”€â”€ slot/                     # Slot utilities
â”‚   â”œâ”€â”€ ğŸ”§ composables/               # Vue 3 composables
â”‚   â”‚   â”œâ”€â”€ use-context.ts            # Provide/inject context management
â”‚   â”‚   â”œâ”€â”€ use-v-model.ts            # v-model binding utilities
â”‚   â”‚   â”œâ”€â”€ use-arrow-navigation.ts   # Keyboard navigation
â”‚   â”‚   â”œâ”€â”€ use-focus-scope.ts        # Focus management
â”‚   â”‚   â”œâ”€â”€ use-dismissable-layer.ts  # Click-outside detection
â”‚   â”‚   â”œâ”€â”€ use-presence.ts           # Enter/exit animations
â”‚   â”‚   â”œâ”€â”€ use-image-loading-status.ts # Image loading state management
â”‚   â”‚   â””â”€â”€ use-*.ts                  # Other reusable composables
â”‚   â”œâ”€â”€ ğŸ¨ shared/                    # Shared utilities
â”‚   â”‚   â”œâ”€â”€ common.ts                 # General utility functions
â”‚   â”‚   â”œâ”€â”€ vue.ts                    # Vue-specific helpers
â”‚   â”‚   â”œâ”€â”€ dom.ts                    # DOM manipulation utilities
â”‚   â”‚   â”œâ”€â”€ focus.ts                  # Focus management helpers
â”‚   â”‚   â””â”€â”€ event.ts                  # Event handling utilities
â”‚   â”œâ”€â”€ ğŸ“ types/                     # TypeScript type definitions
â”‚   â”‚   â”œâ”€â”€ index.ts                  # Main export entry
â”‚   â”‚   â”œâ”€â”€ common.ts                 # Basic common types
â”‚   â”‚   â”œâ”€â”€ style.ts                  # Style-related types
â”‚   â”‚   â”œâ”€â”€ component.ts              # Component-related types
â”‚   â”‚   â”œâ”€â”€ event.ts                  # Event-related types
â”‚   â”‚   â””â”€â”€ props.ts                  # Feature Props types
â”‚   â”œâ”€â”€ ğŸ”¢ constants/                 # Global constants
â”‚   â”‚   â”œâ”€â”€ components.ts             # Component registry for all components
â”‚   â”‚   â”œâ”€â”€ attr.ts                   # HTML attribute constants
â”‚   â”‚   â””â”€â”€ index.ts                  # Constants exports
â”‚   â”œâ”€â”€ ğŸ”Œ resolver/                  # Component resolver
â”‚   â”œâ”€â”€ ğŸš€ nuxt/                      # Nuxt integration
â”‚   â””â”€â”€ index.ts                      # Main export entry
â”œâ”€â”€ ğŸ® playground/                    # Development playground
â”‚   â””â”€â”€ src/examples/                 # Component usage examples
â”œâ”€â”€ ğŸ“š typings/                       # Global type declarations
â”œâ”€â”€ âš™ï¸ Configuration files
â”‚   â”œâ”€â”€ package.json                  # Project metadata & dependencies
â”‚   â”œâ”€â”€ tsconfig.json                 # TypeScript configuration
â”‚   â”œâ”€â”€ vite.config.ts               # Vite configuration
â”‚   â”œâ”€â”€ vitest.config.ts             # Test configuration
â”‚   â”œâ”€â”€ uno.config.ts                # UnoCSS configuration
â”‚   â”œâ”€â”€ tsdown.config.ts             # Build configuration
â”‚   â””â”€â”€ eslint.config.js             # ESLint configuration
â””â”€â”€ ğŸ“„ Documentation
    â”œâ”€â”€ README.md                     # Project documentation
    â”œâ”€â”€ CHANGELOG.md                  # Version changelog
    â””â”€â”€ cursorrule.md                 # This development guide
```

## ğŸ§© Component Architecture

Each component follows a **standardized five-file structure**:

```
src/components/{component-name}/
â”œâ”€â”€ index.ts                    # Export entry point
â”œâ”€â”€ types.ts                    # TypeScript type definitions
â”œâ”€â”€ context.ts                  # Component context management
â”œâ”€â”€ shared.ts                   # Shared constants and utilities (optional)
â”œâ”€â”€ {component-name}-root.vue   # Root component
â”œâ”€â”€ {component-name}-item.vue   # Sub-components (if needed)
â””â”€â”€ {component-name}-xxx.vue    # Additional sub-components
```

### Component Design Principles
- **Headless**: No built-in styling, maximum customization
- **Accessible**: Full ARIA support and keyboard navigation
- **Composable**: Built with Vue 3 Composition API
- **Type-safe**: Complete TypeScript coverage
- **Context-aware**: Uses provide/inject for component communication

## ğŸ“ Naming Conventions

Follow these naming patterns consistently:

- **Files**: Use `kebab-case` (e.g., `accordion-root.vue`, `types.ts`)
- **Components**: Use `PascalCase` for exports (e.g., `AccordionRoot`)
- **Variables**: Use `camelCase` with descriptive names (e.g., `isLoading`, `hasError`)
- **Types**: Use `PascalCase` with clear suffixes (e.g., `ComponentRootProps`, `ComponentRootEmits`)
- **Constants**: Use `UPPER_SNAKE_CASE` (e.g., `DEFAULT_ORIENTATION`)

## ğŸ—ï¸ Component Development Templates

### 1. `index.ts` Export Template
```typescript
import ComponentRoot from './component-root.vue';
import ComponentItem from './component-item.vue';
import ComponentTrigger from './component-trigger.vue';

export { ComponentRoot, ComponentItem, ComponentTrigger };

export type {
  ComponentRootProps,
  ComponentRootEmits,
  ComponentItemProps,
  ComponentTriggerProps
} from './types';
```

### 2. `types.ts` Type Definition Template
```typescript
import type { ComputedRef, Ref, HTMLAttributes } from 'vue';
import type { DataOrientation } from '../../types';

export interface ComponentRootProps extends /** @vue-ignore */ HTMLAttributes {
  /**
   * Brief description of the prop
   * @defaultValue 'default-value'
   */
  orientation?: DataOrientation;
  /**
   * Whether the component is disabled
   * @defaultValue false
   */
  disabled?: boolean;
}

// (å¯é€‰)ï¼Œå¦‚æœæ²¡æœ‰äº‹ä»¶å°±ä¸åˆ›å»º
export type ComponentRootEmits = {
  'update:modelValue': [value: string];
};

export interface ComponentRootContextParams
  extends PropsToContext<ComponentRootProps, 'disabled' | 'orientation'> {
  rootElement: Ref<HTMLElement | null | undefined>;
}

export interface ComponentItemContextParams extends PropsToContext<ComponentItemProps, 'value'> {
  open: ComputedRef<boolean>;
  disabled: ComputedRef<boolean>;
}
```

### 3. `context.ts` Context Management Template

**âš ï¸ é‡è¦åŸåˆ™ï¼šä¼˜å…ˆåœ¨ useContext å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡**

```typescript
import { computed, ref, useId } from 'vue';
import { useContext, useForwardElement } from '../../composables';
import { getDisclosureState } from '../../shared';
import type { DisclosureState } from '../../types';
import type { ComponentRootContextParams, ComponentItemContextParams } from './types';

// âœ… æ¨èï¼šåœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡
export const [provideComponentRootContext, useComponentRootContext] = useContext(
  'ComponentRoot',
  () => {
    // åœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºæ‰€æœ‰å“åº”å¼çŠ¶æ€
    const imageLoadingStatus = ref<ImageLoadingStatus>('idle');
    const isDisabled = ref(false);
    const currentValue = ref('');

    // åˆ›å»ºè®¡ç®—å±æ€§å’Œæ–¹æ³•
    const updateImageLoadingStatus = (status: ImageLoadingStatus) => {
      imageLoadingStatus.value = status;
    };

    const dataState = computed(() => getDisclosureState(isOpen.value));

    return {
      imageLoadingStatus,
      isDisabled,
      currentValue,
      updateImageLoadingStatus,
      dataState
    };
  }
);

// âŒ é¿å…ï¼šä¼ å…¥å¤–éƒ¨åˆ›å»ºçš„å“åº”å¼å˜é‡ä½œä¸ºå‚æ•°
// export const [provideComponentRootContext, useComponentRootContext] = useContext(
//   'ComponentRoot',
//   (params: ComponentRootContextParams) => params
// );

export const [provideComponentItemContext, useComponentItemContext] = useContext(
  'ComponentItem',
  (params: ComponentItemContextParams) => {
    const { open, disabled } = params;

    const [triggerElement, setTriggerElement] = useForwardElement();

    const triggerId = ref('');
    const initTriggerId = () => {
      if (triggerId.value) return;
      triggerId.value = `soybean-component-item-${useId()}`;
    };

    const dataDisabled = computed(() => (disabled.value ? '' : undefined));
    const dataState = computed<DisclosureState>(() => getDisclosureState(open.value));

    return {
      ...params,
      triggerElement,
      setTriggerElement,
      triggerId,
      initTriggerId,
      dataDisabled,
      dataState
    };
  }
);
```

### 4. Vue Component Template
```vue
<script setup lang="ts" generic="T extends AcceptableValue | AcceptableValue[], S extends SingleOrMultipleType">
import { useTemplateRef } from 'vue';
import { useDirection, useSingleOrMultipleValue } from '../../composables';
import { transformPropsToContext } from '../../shared';
import type { AcceptableValue, SingleOrMultipleType } from '../../types';
import { provideComponentRootContext } from './context';
import type { ComponentRootEmits, ComponentRootProps } from './types';

const props = withDefaults(defineProps<ComponentRootProps<T, S>>(), {
  disabled: false,
  orientation: 'vertical',
  collapsible: false,
  unmountOnHide: true
});

const emit = defineEmits<ComponentRootEmits>();

const rootElement = useTemplateRef('rootRef');

// Composables
const { modelValue, isSingle, toggleModelValue } = useSingleOrMultipleValue(props, emit);
const direction = useDirection(() => props.dir);

// Provide context
provideComponentRootContext({
  rootElement,
  modelValue,
  isSingle,
  toggleModelValue,
  direction,
  ...transformPropsToContext(props, ['collapsible', 'disabled', 'orientation', 'unmountOnHide'])
});
</script>

<template>
  <div ref="rootRef" :class="props.class">
    <slot :model-value="modelValue" />
  </div>
</template>
```

### 5. `shared.ts` Constants Template (å¯é€‰)
```typescript
export const componentContentCssVars = {
  width: '--soybean-component-content-width',
  height: '--soybean-component-content-height'
};

export const COMPONENT_CONSTANTS = {
  DEFAULT_ORIENTATION: 'vertical',
  DEFAULT_DISABLED: false
} as const;
```

## ğŸ”§ Core Composables & Utilities

### 1. Context Management (`useContext`)

**æœ€ä½³å®è·µï¼šåœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡**

```typescript
// âœ… æ¨èæ–¹å¼ï¼šå‡½æ•°å†…éƒ¨åˆ›å»ºçŠ¶æ€
const [provideContext, useContext] = useContext('ComponentName', () => {
  // åœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºæ‰€æœ‰å“åº”å¼çŠ¶æ€
  const state = ref('initial');
  const isLoading = ref(false);
  const data = ref(null);

  // åˆ›å»ºæ–¹æ³•
  const updateState = (newState: string) => {
    state.value = newState;
  };

  // åˆ›å»ºè®¡ç®—å±æ€§
  const computedValue = computed(() => state.value.toUpperCase());

  return {
    state,
    isLoading,
    data,
    updateState,
    computedValue
  };
});

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
provideContext(); // ä¸éœ€è¦ä¼ é€’å‚æ•°

// åœ¨å­ç»„ä»¶ä¸­æ¶ˆè´¹
const context = useContext('ConsumerName');
```

### 2. Props to Context Transformation
```typescript
// Transform props to reactive context
const contextProps = transformPropsToContext(props, ['disabled', 'orientation']);
```

### 3. Element Forwarding
```typescript
const [element, setElement] = useForwardElement();
// Used for forwarding DOM references to child components
```

### 4. Single/Multiple Value Management
```typescript
const { modelValue, isSingle, toggleModelValue } = useSingleOrMultipleValue(props, emit);
```

## ğŸ¨ Styling System

// (å¯é€‰)
### CSS Variables Pattern
```typescript
// shared.ts
export const componentCssVars = {
  width: '--soybean-component-width',
  height: '--soybean-component-height'
};
```

### Data Attributes Pattern
```vue
<template>
  <div
    :data-state="dataState"
    :data-disabled="disabled ? '' : undefined"
    :data-orientation="orientation"
    :class="props.class"
  >
    <!-- Content -->
  </div>
</template>
```

## â™¿ Accessibility Requirements

### 1. ARIA Attributes
```vue
<template>
  <button
    :aria-expanded="open"
    :aria-disabled="disabled"
    :aria-controls="contentId"
    :id="triggerId"
    role="button"
  >
    <!-- Trigger content -->
  </button>
</template>
```

### 2. Keyboard Navigation
```typescript
// Use arrow navigation composable
const { handleArrowNavigation } = useArrowNavigation({
  orientation: 'vertical',
  loop: true
});
```

### 3. Focus Management
```typescript
// Use focus scope composable
const { trapFocus, releaseFocus } = useFocusScope();
```

## ğŸ“¦ Export Strategy

### Main Export (`src/index.ts`)
```typescript
export * from './components/accordion';
export * from './components/avatar';
export * from './components/collapsible';
export * from './components/dialog';
export type * from './types';
```

### Component Export (`src/components/[component]/index.ts`)
```typescript
export { ComponentRoot, ComponentItem, ComponentTrigger };
export type { ComponentRootProps, ComponentRootEmits };
```

## ğŸ” Type System Architecture

Types are organized by functionality:

- **`common.ts`**: Basic data types, orientations, functions
- **`style.ts`**: CSS classes and styling types
- **`component.ts`**: Component logic, props transformation, single/multiple patterns
- **`event.ts`**: Custom events and event handlers
- **`props.ts`**: Feature-specific prop interfaces

## ğŸ“‹ Strict Requirements

### Type Safety
- ALL props, emits, and context MUST have explicit TypeScript types
- Always extend `ClassValueProp` for component props
- Use JSDoc comments with `@defaultValue` for all optional props
- Prefer interfaces over types for extensibility

### Vue 3 Best Practices
- ALWAYS use `<script setup>` syntax
- Use `defineProps<T>()` and `defineEmits<T>()` with TypeScript
- Use `useTemplateRef()` instead of ref for template references
- Use `computed()` for derived state
- Use `transformPropsToContext()` helper for context props

### Context Management
- **ä¼˜å…ˆåœ¨ `useContext` å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡**
- Use `useContext()` for provide/inject patterns
- Name context functions as `provide{ComponentName}Context` and `use{ComponentName}Context`
- Include component name in useContext for error handling
- Use `useForwardElement()` for DOM reference forwarding

### Performance
- Use `computed()` for expensive calculations
- Avoid inline functions in templates
- Use `v-if` vs `v-show` appropriately
- Implement proper event handling patterns

### Import Organization
1. Vue imports first
2. Composables and utilities
3. Local component imports
4. Type imports (use `import type`)
5. Constants and shared resources

## ğŸ› ï¸ Development Workflow

### Available Commands
```bash
# Development
pnpm dev          # Build library in watch mode
pnpm play         # Start playground development server

# Building
pnpm build        # Build production bundle
pnpm typecheck    # TypeScript type checking

# Testing & Quality
pnpm test         # Run test suite
pnpm lint         # ESLint code formatting

# Release
pnpm release      # Version bumping and release
pnpm publish-pkg  # Publish to npm
```

### New Component Development Process

1. **Register component in constants**
   ```typescript
   // src/constants/components.ts
   export const components = {
     // ... existing components
     newComponent: ['NewComponentRoot', 'NewComponentItem', 'NewComponentTrigger'],
   };
   ```

2. **Create component directory structure**
   ```bash
   mkdir src/components/new-component
   touch src/components/new-component/{index,types,context}.ts
   touch src/components/new-component/new-component-root.vue
   ```

3. **Implement files following templates**
   - Use the provided templates above
   - Follow naming conventions
   - Implement proper TypeScript types
   - **ä¼˜å…ˆåœ¨ context.ts çš„ useContext å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡**

4. **Add to main export**
   ```typescript
   // src/index.ts
   export * from './components/new-component';
   ```

5. **Create playground example**
   ```bash
   touch playground/src/examples/new-component.vue
   ```

6. **Test and validate**
   ```bash
   pnpm typecheck
   pnpm play
   ```

## âœ… Development Checklist

### New Component Checklist
- [ ] **æ³¨å†Œç»„ä»¶åç§°åˆ° `src/constants/components.ts`**
- [ ] Follow standard directory structure (4-5 files)
- [ ] Implement complete TypeScript types
- [ ] Extend `ClassValueProp` interface
- [ ] Use JSDoc comments with `@defaultValue`
- [ ] **åœ¨ useContext å‡½æ•°å†…éƒ¨åˆ›å»ºå“åº”å¼å˜é‡ï¼ˆè€Œéä¼ å‚ï¼‰**
- [ ] Implement provide/inject context
- [ ] Add ARIA attributes support
- [ ] Support keyboard navigation
- [ ] Use `data-*` attributes for state communication
- [ ] Create playground example
- [ ] Pass TypeScript type checking
- [ ] Add to main export file

### Code Quality Checklist
- [ ] Use functional programming patterns
- [ ] Avoid inline functions in templates
- [ ] Correct import order
- [ ] Descriptive variable naming
- [ ] Defensive programming for optional props
- [ ] Error handling and validation

### Accessibility Checklist
- [ ] Proper ARIA attributes
- [ ] Semantic HTML elements
- [ ] Keyboard navigation support
- [ ] Focus management
- [ ] Screen reader compatibility

## ğŸš€ Development Focus Areas

1. **Accessibility**: ARIA attributes, keyboard navigation, focus management
2. **Type Safety**: Complete TypeScript coverage with strict mode
3. **Performance**: Efficient composables, computed properties, minimal re-renders
4. **Developer Experience**: Clear APIs, good TypeScript intellisense, helpful error messages
5. **Customization**: CSS variables, data attributes, unstyled components

## ğŸ§ª Testing Strategy

### Test Focus Areas
- **Accessibility**: ARIA attributes, keyboard navigation
- **Core Functionality**: Component state management, event handling
- **Type Safety**: TypeScript type checking
- **Edge Cases**: Disabled states, error handling

When developing components, always reference existing implementations like `accordion` or `avatar` for consistency and follow these patterns exactly. The goal is to create a cohesive, accessible, and developer-friendly component library.
