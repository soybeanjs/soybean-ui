---
description:
globs:
alwaysApply: true
---
# Soybean Primitives Cursor Rules

You are an expert Vue 3 + TypeScript developer working on the Soybean Primitives component library. Follow these rules strictly when writing code.

## Project Overview

- **Framework**: Vue 3 with Composition API (script setup)
- **Language**: TypeScript (strict mode)
- **Build Tool**: Vite + tsdown
- **Component Library**: Headless UI primitives for Vue 3
- **Code Style**: Functional and declarative programming patterns

## Directory Structure Rules

### Component Structure
Always organize components following this structure:
```
src/components/{component-name}/
├── index.ts                    # Export entry point
├── types.ts                    # TypeScript type definitions
├── context.ts                  # Component context management
├── shared.ts                   # Shared constants and utilities
├── {component-name}-root.vue   # Root component
├── {component-name}-item.vue   # Sub-components (if needed)
└── {component-name}-xxx.vue    # Additional sub-components
```

## Naming Conventions

- **Files**: Use `kebab-case` (e.g., `accordion-root.vue`, `types.ts`)
- **Components**: Use `PascalCase` for exports (e.g., `AccordionRoot`)
- **Variables**: Use `camelCase` with descriptive names (e.g., `isLoading`, `hasError`)
- **Types**: Use `PascalCase` with clear suffixes (e.g., `ComponentRootProps`, `ComponentRootEmits`)
- **Constants**: Use `UPPER_SNAKE_CASE` (e.g., `DEFAULT_ORIENTATION`)

## Code Writing Rules

### 1. index.ts Pattern
```typescript
import ComponentRoot from './component-root.vue';
import ComponentItem from './component-item.vue';

export { ComponentRoot, ComponentItem };

export type {
  ComponentRootProps,
  ComponentRootEmits,
  ComponentItemProps
} from './types';
```

### 2. types.ts Pattern
```typescript
import type { ComputedRef, Ref } from 'vue';
import type { ClassValueProp, DataOrientation } from '../../types';

export interface ComponentRootProps extends ClassValueProp {
  /**
   * Brief description
   * @defaultValue 'default-value'
   */
  orientation?: DataOrientation;
  disabled?: boolean;
}

export type ComponentRootEmits = {
  'update:modelValue': [value: string];
};

export interface ComponentRootContextParams
  extends PropsToContext<ComponentRootProps, 'disabled' | 'orientation'> {
  rootElement: Ref<HTMLElement | null | undefined>;
}
```

### 3. context.ts Pattern
```typescript
import { computed, ref, useId } from 'vue';
import { useContext, useForwardElement } from '../../composables';

export const [provideComponentRootContext, useComponentRootContext] = useContext(
  'ComponentRoot',
  (params: ComponentRootContextParams) => params
);

export const [provideComponentItemContext, useComponentItemContext] = useContext(
  'ComponentItem',
  (params: ComponentItemContextParams) => {
    const [triggerElement, setElementRef] = useForwardElement();
    const triggerId = ref('');
    const initTriggerId = () => {
      if(triggerId.value) return;
      triggerId.value = `soybean-component-item-${useId()}`;
    }
    const dataState = computed(() => /* logic */);

    return {
      ...params,
      triggerElement,
      setTriggerElement,
      triggerId,
      dataState
    };
  }
);
```

### 4. Vue Component Pattern
```vue
<script setup lang="ts" generic="T extends SomeType">
import { useTemplateRef } from 'vue';
import { transformPropsToContext } from '../../shared';
import { provideComponentRootContext } from './context';
import type { ComponentRootEmits, ComponentRootProps } from './types';

const props = defineProps<ComponentRootProps>();
const emit = defineEmits<ComponentRootEmits>();

const rootElement = useTemplateRef('root');

// Composables
const { modelValue } = useComposable(props, emit);

// Provide context
provideComponentRootContext({
  rootElement,
  ...transformPropsToContext(props, ['key1', 'key2'])
});
</script>

<template>
  <div ref="root" :class="props.class">
    <slot />
  </div>
</template>
```

### 5. shared.ts Pattern
```typescript
export const componentContentCssVars = {
  width: '--soybean-component-content-width',
  height: '--soybean-component-content-height'
};

export const COMPONENT_CONSTANTS = {
  DEFAULT_ORIENTATION: 'vertical',
  DEFAULT_DISABLED: false
} as const;
```

## Strict Requirements

### Type Safety
- ALL props, emits, and context MUST have explicit TypeScript types
- Always extend `ClassValueProp` for component props
- Use JSDoc comments with `@defaultValue` for all optional props
- Prefer interfaces over types for extensibility

### Vue 3 Best Practices
- ALWAYS use `<script setup>` syntax
- Use `defineProps<T>()` and `defineEmits<T>()` with TypeScript
- Use `useTemplateRef()` instead of ref for template references
- Use `computed()` for derived state
- Use `transformPropsToContext()` helper for context props

### Context Management
- Use `useContext()` for provide/inject patterns
- Name context functions as `provide{ComponentName}Context` and `use{ComponentName}Context`
- Include component name in useContext for error handling
- Use `useForwardElement()` for DOM reference forwarding

### Accessibility (A11y)
- Add proper ARIA attributes (aria-disabled, aria-expanded, etc.)
- Use semantic HTML elements
- Implement keyboard navigation with arrow keys
- Use data attributes for state communication to CSS
- Support focus management

### Performance
- Use `computed()` for expensive calculations
- Avoid inline functions in templates
- Use `v-if` vs `v-show` appropriately
- Implement proper event handling patterns

### CSS and Styling
- Define CSS variables in shared.ts
- Use `data-*` attributes for state-based styling
- Support theme customization through CSS variables
- Always support the `class` prop for custom styling

## Import Organization
1. Vue imports first
2. Composables and utilities
3. Local component imports
4. Type imports (use `import type`)
5. Constants and shared resources

## Error Handling
- Always validate context usage with component names
- Handle disabled states properly
- Provide meaningful error messages in development
- Use defensive programming for optional props

## Documentation Requirements
- JSDoc comments for all public APIs
- Include usage examples in complex components
- Document CSS variables and their usage
- Explain accessibility features

## Code Quality
- Follow functional programming patterns
- Avoid classes, prefer composition
- Use descriptive variable names
- Keep components focused and single-purpose
- Extract reusable logic into composables

When generating new components, always follow these patterns exactly and ensure consistency with existing components like `accordion`.
